import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:path_provider/path_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:youtube_downloader/components/download_history_item.dart';
import 'package:youtube_downloader/components/video_item.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'YouTube Downloader',
      theme: ThemeData.dark().copyWith(
        useMaterial3: true,
        scaffoldBackgroundColor: const Color(0xFF121212),
        cardColor: const Color(0xFF1E1E1E),
        primaryColor: Colors.blueAccent,
        appBarTheme: const AppBarTheme(
          backgroundColor: Color(0xFF1E1E1E),
          elevation: 0,
        ),
        inputDecorationTheme: InputDecorationTheme(
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: const BorderSide(color: Colors.grey),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: const BorderSide(color: Colors.blueAccent),
          ),
          filled: true,
          fillColor: const Color(0xFF2D2D2D),
        ),
      ),
      home: const HomePage(),
      // Evita que o drawer feche com clique fora (opcional)
      navigatorObservers: [],
    );
  }
}

class HomePage extends StatefulWidget {
  const HomePage({super.key});

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  final urlController = TextEditingController();
  String? savePath;
  String status = "";
  double progress = 0.0;
  bool isDownloading = false;
  File? binFile;
  List<VideoItem> videos = [];
  bool isLoadingList = false;
  bool selectAll = true;
  final _thumbnailCache = <String, String>{};

  // Controle de navegação do drawer
  int _currentIndex = 0;
  final List<String> _titles = [
    'Início',
    'Histórico',
    'Configurações',
    'Ajuda',
    'Sobre',
  ];

  // Configurações
  String audioQuality = "Alta (320kbps)";
  String videoQuality = "720p";

  // Histórico
  List<DownloadHistoryItem> downloadHistory = [];

  @override
  void initState() {
    super.initState();
    setState(() => status = "Checando yt-dlp...");
    _prepareBinary();
    _loadHistory();
  }

  @override
  void dispose() {
    urlController.dispose();
    super.dispose();
  }

  Widget _getPage() {
    switch (_currentIndex) {
      case 0:
        return _buildMainPage();
      case 1:
        return _buildHistoryPage();
      case 2:
        return _buildSettingsPage();
      case 3:
        return _buildHelpPage();
      case 4:
        return _buildAboutPage();
      default:
        return const SizedBox();
    }
  }

  void _onItemTapped(int index) {
    setState(() {
      _currentIndex = index;
    });
  }

  /// ================== HISTÓRICO ==================
  Future<void> _loadHistory() async {
    final prefs = await SharedPreferences.getInstance();
    final historyJson = prefs.getStringList('download_history') ?? [];
    downloadHistory = historyJson.map((json) {
      final data = jsonDecode(json) as Map<String, dynamic>;
      return DownloadHistoryItem(
        title: data['title'],
        url: data['url'],
        type: data['type'],
        date: DateTime.parse(data['date']),
        filePath: data['filePath'],
      );
    }).toList();
  }

  Future<void> _saveToHistory(DownloadHistoryItem item) async {
    final prefs = await SharedPreferences.getInstance();
    final json = jsonEncode({
      'title': item.title,
      'url': item.url,
      'type': item.type,
      'date': item.date.toIso8601String(),
      'filePath': item.filePath,
    });
    final history = prefs.getStringList('download_history') ?? [];
    history.insert(0, json); // Adiciona no início
    if (history.length > 50) history.removeRange(50, history.length);
    await prefs.setStringList('download_history', history);
    downloadHistory.insert(0, item);
  }

  /// ================== yt-dlp UPDATE ==================
  Future<File> _getBinaryPath() async {
    final dir = await getApplicationSupportDirectory();
    final binName = Platform.isWindows ? "yt-dlp.exe" : "yt-dlp";
    return File("${dir.path}/$binName");
  }

  Future<String?> _getLocalVersion() async {
    if (binFile == null || !(await binFile!.exists())) return null;
    try {
      final result = await Process.run(binFile!.path, ["--version"]);
      return (result.stdout as String).trim();
    } catch (e) {
      return null;
    }
  }

  Future<Map<String, String>?> _getLatestRelease() async {
    const api = "https://api.github.com/repos/yt-dlp/yt-dlp/releases/latest";
    try {
      final res = await http.get(Uri.parse(api));
      final data = jsonDecode(res.body);
      final version = (data["tag_name"] as String).replaceFirst("v", "");
      for (final asset in data["assets"]) {
        final name = asset["name"] as String;
        if (Platform.isWindows && name.endsWith(".exe")) {
          return {"version": version, "url": asset["browser_download_url"]};
        } else if (!Platform.isWindows &&
            (name.contains("yt-dlp") && !name.endsWith(".exe"))) {
          return {"version": version, "url": asset["browser_download_url"]};
        }
      }
    } catch (_) {
      return null;
    }
    return null;
  }

  Future<void> _downloadBinary(String url) async {
    setState(() => status = "⬇️ Baixando yt-dlp...");
    final res = await http.Client().send(http.Request("GET", Uri.parse(url)));
    final sink = binFile!.openWrite();
    await res.stream.pipe(sink);
    await sink.close();
    if (!Platform.isWindows) {
      await Process.run("chmod", ["+x", binFile!.path]);
    }
  }

  Future<void> _prepareBinary() async {
    try {
      binFile = await _getBinaryPath();
      final localVer = await _getLocalVersion();
      final latest = await _getLatestRelease();

      if (latest == null) {
        if (mounted) setState(() => status = "⚠️ Falha ao checar yt-dlp");
        return;
      }

      if (localVer == null) {
        await _downloadBinary(latest["url"]!);
        if (mounted)
          setState(() => status = "✅ yt-dlp instalado (${latest["version"]})");
      } else if (localVer != latest["version"]) {
        await _downloadBinary(latest["url"]!);
        if (mounted)
          setState(() => status = "✅ yt-dlp atualizado (${latest["version"]})");
      } else {
        if (mounted)
          setState(() => status = "✅ yt-dlp já está atualizado ($localVer)");
      }
    } catch (e, st) {
      if (mounted) setState(() => status = "❌ Erro ao preparar yt-dlp");
    }
  }

  /// ================== VIDEO LIST ==================
  Future<void> loadVideosFromUrl(String url) async {
    if (url.isEmpty || !url.contains("youtube.com")) {
      setState(() => status = "⚠️ URL inválida. Insira uma URL do YouTube.");
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("URL inválida. Deve conter youtube.com")),
      );
      return;
    }

    setState(() {
      isLoadingList = true;
      videos.clear();
      status = "Carregando vídeos...";
    });

    try {
      final process = await Process.run(binFile!.path, [
        "--flat-playlist",
        "-J",
        url,
      ]);

      if (process.exitCode != 0) {
        setState(() {
          status =
              "❌ Erro ao carregar: ${process.stderr.toString().substring(0, 50)}...";
          isLoadingList = false;
        });
        return;
      }

      final data = jsonDecode(process.stdout);

      List<VideoItem> newVideos = [];

      if (data is Map && data.containsKey("entries")) {
        final entries = (data["entries"] as List).cast<Map<String, dynamic>>();
        newVideos = entries
            .map(
              (e) => VideoItem(
                id: e["id"] ?? "",
                title: e["title"] ?? "Sem título",
                url: e["url"] ?? "https://youtube.com/watch?v=${e["id"]}",
              ),
            )
            .toList();
      } else {
        newVideos = [
          VideoItem(
            id: data["id"] ?? "",
            title: data["title"] ?? "Sem título",
            url:
                data["webpage_url"] ??
                "https://youtube.com/watch?v=${data["id"]}",
          ),
        ];
      }

      setState(() {
        videos = newVideos;
        status =
            "✅ ${videos.length} vídeo(s) carregado(s). Buscando detalhes...";
      });

      final chunks = _chunkList(videos, 5);
      for (final chunk in chunks) {
        await Future.wait(chunk.map((v) => fetchDetails(v)));
      }

      setState(() {
        status = "✅ Pronto para baixar (${videos.length} vídeos)";
        isLoadingList = false;
        selectAll = true;
      });
    } catch (e) {
      setState(() {
        status = "Erro ao carregar: $e";
        isLoadingList = false;
      });
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text("Erro: $e")));
    }
  }

  List<List<T>> _chunkList<T>(List<T> list, int chunkSize) {
    final chunks = <List<T>>[];
    for (var i = 0; i < list.length; i += chunkSize) {
      chunks.add(
        list.sublist(
          i,
          i + chunkSize > list.length ? list.length : i + chunkSize,
        ),
      );
    }
    return chunks;
  }

  Future<void> fetchDetails(VideoItem video) async {
    if (_thumbnailCache.containsKey(video.id)) {
      setState(() {
        video.thumbnail = _thumbnailCache[video.id]!;
        video.isLoadingDetails = false;
      });
      return;
    }

    setState(() => video.isLoadingDetails = true);
    try {
      final process = await Process.run(binFile!.path, [
        "--no-playlist",
        "-J",
        video.url,
      ]);

      if (process.exitCode == 0) {
        final data = jsonDecode(process.stdout);
        final thumb = data["thumbnail"] ?? "";
        final duration = _formatDuration(data["duration"]);
        _thumbnailCache[video.id] = thumb;

        if (mounted) {
          setState(() {
            video.thumbnail = thumb;
            video.duration = duration;
            video.isLoadingDetails = false;
          });
        }
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          video.isLoadingDetails = false;
        });
      }
    }
  }

  String _formatDuration(dynamic seconds) {
    if (seconds == null || seconds <= 0) return "--:--";
    final dur = Duration(seconds: seconds as int);
    String twoDigits(int n) => n.toString().padLeft(2, "0");
    final mins = dur.inMinutes;
    final secs = dur.inSeconds.remainder(60);
    return "${twoDigits(mins)}:${twoDigits(secs)}";
  }

  /// ================== DOWNLOAD ==================
  Future<void> startDownload({bool audioOnly = true}) async {
    final selectedVideos = videos.where((v) => v.selected).toList();
    if (selectedVideos.isEmpty) {
      setState(() => status = "⚠️ Nenhum vídeo selecionado.");
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Selecione ao menos um vídeo.")),
      );
      return;
    }
    if (savePath == null) {
      setState(() => status = "⚠️ Escolha uma pasta.");
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("Escolha uma pasta de destino.")),
      );
      return;
    }

    setState(() {
      isDownloading = true;
      progress = 0.0;
      status = "Iniciando downloads...";
    });

    final totalVideos = selectedVideos.length;
    var completed = 0;

    for (final video in selectedVideos) {
      final args = <String>[
        video.url,
        "-o",
        "$savePath/%(title)s.%(ext)s",
        "--no-playlist",
        "--quiet",
        "--no-warnings",
      ];

      if (audioOnly) {
        final quality = audioQuality == "Alta (320kbps)" ? "320k" : "192k";
        args.insertAll(1, [
          "-x",
          "--audio-format",
          "mp3",
          "--audio-quality",
          quality,
        ]);
      } else {
        final format = videoQuality == "720p"
            ? "bestvideo[height<=720]+bestaudio"
            : "best";
        args.insertAll(1, ["-f", format]);
      }

      setState(() => status = "Baixando: ${video.title}");

      final process = await Process.start(binFile!.path, args);
      var lastPercent = 0.0;

      process.stdout
          .transform(utf8.decoder)
          .transform(const LineSplitter())
          .listen((line) {
            final match = RegExp(r"(\d+\.\d+)%").firstMatch(line);
            if (match != null) {
              final percent = double.tryParse(match.group(1)!) ?? 0.0;
              if ((percent - lastPercent).abs() > 0.5) {
                lastPercent = percent;
                setState(() {
                  progress = (completed + percent / 100) / totalVideos;
                });
              }
            }
          });

      final exitCode = await process.exitCode;
      completed++;

      if (exitCode == 0) {
        // Salva no histórico
        final fileTitle = video.title.length > 50
            ? "${video.title.substring(0, 50)}..."
            : video.title;
        final filePath = "$savePath/${video.title}.mp3";
        await _saveToHistory(
          DownloadHistoryItem(
            title: fileTitle,
            url: video.url,
            type: audioOnly ? "MP3" : "MP4",
            date: DateTime.now(),
            filePath: filePath,
          ),
        );

        setState(() {
          video.downloaded = true;
          status = "✅ ${video.title} concluído";
        });
      } else {
        setState(() {
          video.error = "Falha no download";
          status = "⚠️ Erro ao baixar: ${video.title}";
        });
      }
    }

    setState(() {
      status = "✅ Todos os downloads concluídos!";
      isDownloading = false;
      progress = 1.0;
    });

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text("✅ $totalVideos arquivos baixados!")),
    );
  }

  /// ================== UI HELPERS ==================
  Future<void> pickFolder() async {
    String? selected = await FilePicker.platform.getDirectoryPath();
    if (selected != null && mounted) {
      setState(() {
        savePath = selected;
      });
    }
  }

  void clearList() {
    setState(() {
      videos.clear();
      status = "Lista limpa.";
    });
  }

  Widget buildVideoList() {
    return Column(
      children: [
        Row(
          children: [
            Checkbox(
              value: selectAll,
              onChanged: (val) {
                setState(() {
                  selectAll = val ?? false;
                  for (var v in videos) v.selected = selectAll;
                });
              },
            ),
            const Text("Selecionar todos", style: TextStyle(fontSize: 16)),
            const Spacer(),
            TextButton.icon(
              icon: const Icon(Icons.delete_outline, size: 16),
              label: const Text("Limpar", style: TextStyle(fontSize: 14)),
              onPressed: clearList,
            ),
          ],
        ),
        const Divider(),
        Expanded(
          child: ListView.builder(
            itemCount: videos.length,
            itemBuilder: (context, index) {
              final v = videos[index];
              return Card(
                margin: const EdgeInsets.symmetric(vertical: 4),
                elevation: 2,
                child: CheckboxListTile(
                  dense: true,
                  activeColor: Colors.blueAccent,
                  value: v.selected,
                  onChanged: (val) {
                    setState(() {
                      v.selected = val ?? false;
                      selectAll = videos.every((v) => v.selected);
                    });
                  },
                  title: Row(
                    children: [
                      Stack(
                        alignment: Alignment.center,
                        children: [
                          ClipRRect(
                            borderRadius: BorderRadius.circular(8),
                            child: v.thumbnail.isNotEmpty
                                ? Image.network(
                                    v.thumbnail,
                                    width: 90,
                                    height: 50,
                                    fit: BoxFit.cover,
                                    errorBuilder: (_, __, ___) => Container(
                                      width: 90,
                                      height: 50,
                                      color: Colors.grey[800],
                                      child: const Icon(
                                        Icons.broken_image,
                                        color: Colors.grey,
                                      ),
                                    ),
                                  )
                                : Container(
                                    width: 90,
                                    height: 50,
                                    color: Colors.grey[700],
                                    child: const Icon(
                                      Icons.image_not_supported,
                                    ),
                                  ),
                          ),
                          if (v.isLoadingDetails)
                            Container(
                              width: 90,
                              height: 50,
                              color: Colors.black54,
                              child: const SizedBox(
                                width: 16,
                                height: 16,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                  color: Colors.white,
                                ),
                              ),
                            ),
                          if (v.downloaded)
                            Positioned(
                              bottom: 2,
                              right: 2,
                              child: Container(
                                padding: const EdgeInsets.all(2),
                                color: Colors.green.withOpacity(0.8),
                                child: const Icon(
                                  Icons.check,
                                  size: 12,
                                  color: Colors.white,
                                ),
                              ),
                            ),
                        ],
                      ),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              v.title,
                              style: const TextStyle(
                                fontSize: 14,
                                fontWeight: FontWeight.w600,
                              ),
                              maxLines: 2,
                              overflow: TextOverflow.ellipsis,
                            ),
                            const SizedBox(height: 4),
                            Row(
                              children: [
                                const Icon(
                                  Icons.access_time,
                                  size: 12,
                                  color: Colors.white70,
                                ),
                                const SizedBox(width: 4),
                                Text(
                                  v.duration,
                                  style: const TextStyle(
                                    fontSize: 12,
                                    color: Colors.white70,
                                  ),
                                ),
                              ],
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }

  /// ================== PÁGINAS DO DRAWER ==================
  Widget _buildMainPage() {
    return Column(
      children: [
        TextField(
          controller: urlController,
          decoration: InputDecoration(
            labelText: "URL do YouTube (vídeo ou playlist)",
            hintText: "https://www.youtube.com/playlist?list=...",
            prefixIcon: const Icon(Icons.link),
            suffixIcon: IconButton(
              icon: const Icon(Icons.clear),
              onPressed: () => urlController.clear(),
            ),
          ),
          textInputAction: TextInputAction.go,
          onSubmitted: (url) => loadVideosFromUrl(url),
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            Expanded(
              child: ElevatedButton.icon(
                onPressed: pickFolder,
                icon: const Icon(Icons.folder_open),
                label: const Text("Escolher Pasta"),
              ),
            ),
            const SizedBox(width: 10),
            Expanded(
              child: Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 12,
                  vertical: 10,
                ),
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(12),
                  color: Colors.grey[800],
                ),
                child: Text(
                  savePath?.split('/').last ?? "Nenhuma pasta",
                  style: const TextStyle(fontSize: 12),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            Expanded(
              child: ElevatedButton(
                onPressed: isLoadingList || isDownloading
                    ? null
                    : () => loadVideosFromUrl(urlController.text),
                child: isLoadingList
                    ? const SizedBox(
                        width: 20,
                        height: 20,
                        child: CircularProgressIndicator(strokeWidth: 2),
                      )
                    : const Text("Carregar Vídeos"),
              ),
            ),
            const SizedBox(width: 10),
            ElevatedButton(
              onPressed: videos.isEmpty ? null : clearList,
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.grey[700],
              ),
              child: const Text("Limpar"),
            ),
          ],
        ),
        const SizedBox(height: 16),
        if (isLoadingList) const LinearProgressIndicator(),
        const SizedBox(height: 10),
        if (videos.isNotEmpty) Expanded(child: buildVideoList()),
        const SizedBox(height: 10),
        if (isDownloading) LinearProgressIndicator(value: progress),

        const SizedBox(height: 8),
        if (status.isNotEmpty)
          Text(
            status.isNotEmpty ? status : "Aguardando ação...",
            maxLines: 2,
            textAlign: TextAlign.center,
            style: TextStyle(
              color: status.startsWith("✅")
                  ? Colors.greenAccent
                  : status.startsWith("⚠️") || status.startsWith("❌")
                  ? Colors.orange
                  : Colors.white70,
              fontSize: 12,
              fontStyle: status.contains("Erro") ? FontStyle.italic : null,
            ),
          ),

        const SizedBox(height: 16),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            Expanded(
              child: ElevatedButton.icon(
                onPressed: isDownloading || videos.isEmpty
                    ? null
                    : () => startDownload(audioOnly: true),
                icon: const Icon(Icons.music_note),
                label: const Text("MP3 (Áudio)"),
                style: ElevatedButton.styleFrom(backgroundColor: Colors.green),
              ),
            ),
            const SizedBox(width: 10),
            Expanded(
              child: ElevatedButton.icon(
                onPressed: isDownloading || videos.isEmpty
                    ? null
                    : () => startDownload(audioOnly: false),
                icon: const Icon(Icons.movie),
                label: const Text("MP4 (Vídeo)"),
                style: ElevatedButton.styleFrom(backgroundColor: Colors.blue),
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildHistoryPage() {
    if (downloadHistory.isEmpty) {
      return const Center(
        child: Text(
          "Nenhum download ainda.\nSeus arquivos aparecerão aqui.",
          textAlign: TextAlign.center,
          style: TextStyle(color: Colors.grey, fontSize: 16),
        ),
      );
    }

    return ListView.builder(
      itemCount: downloadHistory.length,
      itemBuilder: (context, index) {
        final item = downloadHistory[index];
        return Card(
          margin: const EdgeInsets.symmetric(vertical: 4),
          child: ListTile(
            leading: item.type == "MP3"
                ? const Icon(Icons.music_note, color: Colors.green)
                : const Icon(Icons.movie, color: Colors.blue),
            title: Text(
              item.title,
              style: const TextStyle(fontWeight: FontWeight.w600),
            ),
            subtitle: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(item.type, style: const TextStyle(fontSize: 12)),
                Text(
                  "${item.date.day}/${item.date.month} às ${item.date.hour}:${item.date.minute}",
                  style: const TextStyle(fontSize: 12, color: Colors.white70),
                ),
              ],
            ),
            trailing: IconButton(
              icon: const Icon(Icons.folder_open, size: 18),
              onPressed: () => _openFolder(item.filePath),
            ),
          ),
        );
      },
    );
  }

  Future<void> _openFolder(String path) async {
    final file = File(path);
    if (await file.exists()) {
      await Process.start("explorer", ["/select,", path]); // Windows
    } else {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(const SnackBar(content: Text("Arquivo não encontrado")));
    }
  }

  Widget _buildSettingsPage() {
    return ListView(
      padding: const EdgeInsets.all(20),
      children: [
        const Text(
          "Configurações",
          style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 20),
        ListTile(
          title: const Text("Qualidade de Áudio"),
          subtitle: Text(audioQuality),
          trailing: DropdownButton<String>(
            value: audioQuality,
            items: const [
              DropdownMenuItem(
                value: "Alta (320kbps)",
                child: Text("Alta - 320kbps"),
              ),
              DropdownMenuItem(
                value: "Média (192kbps)",
                child: Text("Média - 192kbps"),
              ),
            ],
            onChanged: (value) {
              setState(() {
                audioQuality = value!;
              });
            },
          ),
        ),
        ListTile(
          title: const Text("Qualidade de Vídeo"),
          subtitle: Text(videoQuality),
          trailing: DropdownButton<String>(
            value: videoQuality,
            items: const [
              DropdownMenuItem(value: "720p", child: Text("720p HD")),
              DropdownMenuItem(value: "1080p", child: Text("1080p Full HD")),
              DropdownMenuItem(
                value: "Melhor",
                child: Text("Melhor disponível"),
              ),
            ],
            onChanged: (value) {
              setState(() {
                videoQuality = value!;
              });
            },
          ),
        ),
        const SizedBox(height: 20),
        const Text(
          "Pasta de Downloads",
          style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 8),
        ElevatedButton.icon(
          onPressed: pickFolder,
          icon: const Icon(Icons.folder_open),
          label: const Text("Alterar Pasta"),
        ),
        if (savePath != null)
          Padding(
            padding: const EdgeInsets.only(top: 8),
            child: Text(
              "Atual: ${savePath!.split('/').last}",
              style: const TextStyle(fontSize: 12, color: Colors.grey),
            ),
          ),
      ],
    );
  }

  Widget _buildHelpPage() {
    return ListView(
      padding: const EdgeInsets.all(20),
      children: [
        const Text(
          "Ajuda",
          style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 20),
        const Text(
          "Como usar o YouTube Downloader:",
          style: TextStyle(fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 8),
        const Text("1. Cole a URL de um vídeo ou playlist do YouTube."),
        const Text("2. Clique em 'Carregar Vídeos' para listar os itens."),
        const Text("3. Escolha a pasta de destino com 'Escolher Pasta'."),
        const Text(
          "4. Selecione os vídeos desejados (ou desmarque os indesejados).",
        ),
        const Text("5. Clique em 'MP3' para áudio ou 'MP4' para vídeo."),
        const SizedBox(height: 20),
        const Text("Dicas:", style: TextStyle(fontWeight: FontWeight.bold)),
        const SizedBox(height: 8),
        const Text("• Suporta playlists grandes e vídeos únicos."),
        const Text("• O yt-dlp é atualizado automaticamente."),
        const Text("• O histórico mostra os últimos downloads."),
      ],
    );
  }

  Widget _buildAboutPage() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(
            Icons.download_outlined,
            size: 80,
            color: Colors.blueAccent,
          ),
          const SizedBox(height: 16),
          const Text(
            "YouTube Downloader",
            style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          const Text("Versão 1.0.0", style: TextStyle(color: Colors.grey)),
          const SizedBox(height: 16),
          const Text(
            "Feito com Flutter e yt-dlp.\nBaixe vídeos e áudios do YouTube facilmente.",
            textAlign: TextAlign.center,
            style: TextStyle(color: Colors.white70),
          ),
          const SizedBox(height: 20),
          const Text("© 2025 - Todos os direitos reservados"),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(
          _titles[_currentIndex],
          style: const TextStyle(fontSize: 20),
        ),
        actions: _currentIndex == 0
            ? [
                IconButton(
                  icon: const Icon(Icons.refresh),
                  onPressed: () => _prepareBinary(),
                  tooltip: "Atualizar yt-dlp",
                ),
              ]
            : null,
      ),
      drawer: Drawer(
        child: ListView(
          padding: EdgeInsets.zero,
          children: [
            DrawerHeader(
              decoration: const BoxDecoration(color: Color(0xFF1E1E1E)),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  const Icon(
                    Icons.download_done,
                    size: 40,
                    color: Colors.blueAccent,
                  ),
                  const SizedBox(height: 8),
                  const Text(
                    "YouTube Downloader",
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  Text(
                    "Baixe seus conteúdos",
                    style: TextStyle(color: Colors.grey[400], fontSize: 12),
                  ),
                ],
              ),
            ),
            ListTile(
              leading: const Icon(Icons.home),
              title: const Text('Início'),
              selected: _currentIndex == 0,
              onTap: () {
                setState(() {
                  _currentIndex = 0;
                });
                Navigator.pop(context);
              },
            ),
            ListTile(
              leading: const Icon(Icons.history),
              title: const Text('Histórico'),
              selected: _currentIndex == 1,
              onTap: () {
                setState(() {
                  _currentIndex = 1;
                });
                Navigator.pop(context);
              },
            ),
            ListTile(
              leading: const Icon(Icons.settings),
              title: const Text('Configurações'),
              selected: _currentIndex == 2,
              onTap: () {
                setState(() {
                  _currentIndex = 2;
                });
                Navigator.pop(context);
              },
            ),
            ListTile(
              leading: const Icon(Icons.help),
              title: const Text('Ajuda'),
              selected: _currentIndex == 3,
              onTap: () {
                setState(() {
                  _currentIndex = 3;
                });
                Navigator.pop(context);
              },
            ),
            ListTile(
              leading: const Icon(Icons.info),
              title: const Text('Sobre'),
              selected: _currentIndex == 4,
              onTap: () {
                setState(() {
                  _currentIndex = 4;
                });
                Navigator.pop(context);
              },
            ),
          ],
        ),
      ),
      body: _getPage(),
    );
  }
}
